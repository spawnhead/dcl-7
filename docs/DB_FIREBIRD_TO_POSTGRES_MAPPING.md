# Firebird → PostgreSQL Mapping Plan

Source of truth: `db/Lintera_dcl-5_schema.ddl`.

## Type mapping (observed in DDL)

| Firebird type | Postgres type | Notes |
| --- | --- | --- |
| `INTEGER` | `INTEGER` | Direct mapping for PK/FK candidates. |
| `SMALLINT` | `SMALLINT` | Direct mapping. |
| `SMALLINTNN` (domain) | `SMALLINT NOT NULL` | Recreate as `SMALLINT NOT NULL` or a domain in Postgres. |
| `DECIMAL(p,s)` | `NUMERIC(p,s)` | Preserve precision/scale as-is. |
| `CHAR(1)` | `CHAR(1)` | Direct mapping (often used for flags). |
| `VARCHAR(n)` | `VARCHAR(n)` | Keep lengths; adjust if App-level constraints require. |
| `DATE` | `DATE` | Direct mapping. |
| `TIME` | `TIME` | Direct mapping. |
| `TIMESTAMP` | `TIMESTAMP` | Prefer `TIMESTAMP WITHOUT TIME ZONE` unless legacy indicates TZ usage. |

## Generators → sequences / identity

### Firebird pattern in DDL
- Generators are declared with `CREATE GENERATOR`.
- BEFORE INSERT triggers call `GEN_ID` to populate IDs (81 such triggers in DDL).

### Postgres replacement
- For each generator, create a `SEQUENCE` in a Flyway migration.
- Replace the Firebird trigger mechanism with one of:
  - `GENERATED BY DEFAULT AS IDENTITY` on the PK column, or
  - `DEFAULT nextval('sequence_name')` if a separate sequence is required.
- For tables where the trigger sets non-ID fields (besides `GEN_ID`), preserve that logic in a Postgres trigger or move to the application layer (document decision per table).

## Triggers → PL/pgSQL or application logic

### Observed trigger patterns
- Naming indicates lifecycle timing (`BI0`, `BU0`, `BD0`, `AI0`, `AU0`, `AD0`).
- Many triggers appear to be auto-ID assignment and possibly audit/state adjustments.

### Migration guidance
- **Pure ID assignment**: replace with identity/sequence defaults; avoid Postgres trigger when no other logic is needed.
- **Business-rule triggers**: re-implement in PL/pgSQL **or** move to domain services if the rule is better expressed in the application layer.
- **Audit or denormalization triggers**: keep in the DB if they are integrity-critical; otherwise consider app-layer with tests.

## Views
- Views should be re-created in Postgres with equivalent SQL.
- Validate usage in legacy Java (DAO queries) to decide whether they are still needed or can be replaced with explicit queries in the new domain modules.

## Stored procedures
- 231 stored procedures are defined in the DDL (e.g., filter/load/insert routines). These require triage:
  - Move pure data-access procedures into repositories or queries.
  - Preserve business-critical procedures as Postgres functions/procedures with tests.
  - Document which ones are retired or replaced by domain services.

## Constraints & indexing
- The DDL defines primary keys and a small set of unique constraints, but **no foreign keys** are declared.
- In migration, introduce FK constraints only after verifying implicit relationships in legacy DAO queries and business rules.

## Decision log template (per table or trigger)
- **Legacy object**: `TRIGGER_NAME` / `GENERATOR_NAME`
- **Behavior**: _brief description of logic_
- **Migration choice**: `DB trigger` / `App layer` / `Sequence default`
- **Justification**: _why this location_
- **Tests**: _unit/integration tests added_
